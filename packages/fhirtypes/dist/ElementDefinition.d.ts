/*
 * Generated by @medplum/generator
 * Do not edit manually.
 */

import { Address } from './Address';
import { Age } from './Age';
import { Annotation } from './Annotation';
import { Attachment } from './Attachment';
import { CodeableConcept } from './CodeableConcept';
import { Coding } from './Coding';
import { ContactDetail } from './ContactDetail';
import { ContactPoint } from './ContactPoint';
import { Contributor } from './Contributor';
import { Count } from './Count';
import { DataRequirement } from './DataRequirement';
import { Distance } from './Distance';
import { Dosage } from './Dosage';
import { Duration } from './Duration';
import { Expression } from './Expression';
import { Extension } from './Extension';
import { HumanName } from './HumanName';
import { Identifier } from './Identifier';
import { Meta } from './Meta';
import { Money } from './Money';
import { ParameterDefinition } from './ParameterDefinition';
import { Period } from './Period';
import { Quantity } from './Quantity';
import { Range } from './Range';
import { Ratio } from './Ratio';
import { Reference } from './Reference';
import { RelatedArtifact } from './RelatedArtifact';
import { SampledData } from './SampledData';
import { Signature } from './Signature';
import { Timing } from './Timing';
import { TriggerDefinition } from './TriggerDefinition';
import { UsageContext } from './UsageContext';

/**
 * Base StructureDefinition for ElementDefinition Type: Captures
 * constraints on each element within the resource, profile, or
 * extension.
 */
export interface ElementDefinition {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element and that modifies the
   * understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually
   * modifier elements provide negation or qualification. To make the use
   * of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any
   * implementer can define an extension, there is a set of requirements
   * that SHALL be met as part of the definition of the extension.
   * Applications processing a resource are required to check for modifier
   * extensions.
   *
   * Modifier extensions SHALL NOT change the meaning of any elements on
   * Resource or DomainResource (including cannot change the meaning of
   * modifierExtension itself).
   */
  readonly modifierExtension?: Extension[];

  /**
   * The path identifies the element and is expressed as a &quot;.&quot;-separated
   * list of ancestor elements, beginning with the name of the resource or
   * extension.
   */
  readonly path?: string;

  /**
   * Codes that define how this element is represented in instances, when
   * the deviation varies from the normal case.
   */
  readonly representation?: string[];

  /**
   * The name of this element definition slice, when slicing is working.
   * The name must be a token with no dots or spaces. This is a unique name
   * referring to a specific set of constraints applied to this element,
   * used to provide a name to different slices of the same element.
   */
  readonly sliceName?: string;

  /**
   * If true, indicates that this slice definition is constraining a slice
   * definition with the same name in an inherited profile. If false, the
   * slice is not overriding any slice in an inherited profile. If missing,
   * the slice might or might not be overriding a slice in an inherited
   * profile, depending on the sliceName.
   */
  readonly sliceIsConstraining?: boolean;

  /**
   * A single preferred label which is the text to display beside the
   * element indicating its meaning or to use to prompt for the element in
   * a user display or form.
   */
  readonly label?: string;

  /**
   * A code that has the same meaning as the element in a particular
   * terminology.
   */
  readonly code?: Coding[];

  /**
   * Indicates that the element is sliced into a set of alternative
   * definitions (i.e. in a structure definition, there are multiple
   * different constraints on a single element in the base resource).
   * Slicing can be used in any resource that has cardinality ..* on the
   * base resource, or any resource with a choice of types. The set of
   * slices is any elements that come after this in the element sequence
   * that have the same path, until a shorter path occurs (the shorter path
   * terminates the set).
   */
  readonly slicing?: ElementDefinitionSlicing;

  /**
   * A concise description of what this element means (e.g. for use in
   * autogenerated summaries).
   */
  readonly short?: string;

  /**
   * Provides a complete explanation of the meaning of the data element for
   * human readability.  For the case of elements derived from existing
   * elements (e.g. constraints), the definition SHALL be consistent with
   * the base definition, but convey the meaning of the element in the
   * particular context of use of the resource. (Note: The text you are
   * reading is specified in ElementDefinition.definition).
   */
  readonly definition?: string;

  /**
   * Explanatory notes and implementation guidance about the data element,
   * including notes about how to use the data properly, exceptions to
   * proper use, etc. (Note: The text you are reading is specified in
   * ElementDefinition.comment).
   */
  readonly comment?: string;

  /**
   * This element is for traceability of why the element was created and
   * why the constraints exist as they do. This may be used to point to
   * source materials or specifications that drove the structure of this
   * element.
   */
  readonly requirements?: string;

  /**
   * Identifies additional names by which this element might also be known.
   */
  readonly alias?: string[];

  /**
   * The minimum number of times this element SHALL appear in the instance.
   */
  readonly min?: number;

  /**
   * The maximum number of times this element is permitted to appear in the
   * instance.
   */
  readonly max?: string;

  /**
   * Information about the base definition of the element, provided to make
   * it unnecessary for tools to trace the deviation of the element through
   * the derived and related profiles. When the element definition is not
   * the original definition of an element - i.g. either in a constraint on
   * another type, or for elements from a super type in a snap shot - then
   * the information in provided in the element definition may be different
   * to the base definition. On the original definition of the element, it
   * will be same.
   */
  readonly base?: ElementDefinitionBase;

  /**
   * Identifies an element defined elsewhere in the definition whose
   * content rules should be applied to the current element.
   * ContentReferences bring across all the rules that are in the
   * ElementDefinition for the element, including definitions, cardinality
   * constraints, bindings, invariants etc.
   */
  readonly contentReference?: string;

  /**
   * The data type or resource that the value of this element is permitted
   * to be.
   */
  readonly type?: ElementDefinitionType[];

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueBase64Binary?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueBoolean?: boolean;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueCanonical?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueCode?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDate?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDateTime?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDecimal?: number;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueId?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueInstant?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueInteger?: number;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueMarkdown?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueOid?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValuePositiveInt?: number;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueString?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueTime?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueUnsignedInt?: number;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueUri?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueUrl?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueUuid?: string;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueAddress?: Address;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueAge?: Age;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueAnnotation?: Annotation;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueAttachment?: Attachment;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueCodeableConcept?: CodeableConcept;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueCoding?: Coding;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueContactPoint?: ContactPoint;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueCount?: Count;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDistance?: Distance;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDuration?: Duration;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueHumanName?: HumanName;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueIdentifier?: Identifier;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueMoney?: Money;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValuePeriod?: Period;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueQuantity?: Quantity;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueRange?: Range;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueRatio?: Ratio;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueReference?: Reference;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueSampledData?: SampledData;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueSignature?: Signature;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueTiming?: Timing;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueContactDetail?: ContactDetail;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueContributor?: Contributor;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDataRequirement?: DataRequirement;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueExpression?: Expression;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueParameterDefinition?: ParameterDefinition;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueRelatedArtifact?: RelatedArtifact;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueTriggerDefinition?: TriggerDefinition;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueUsageContext?: UsageContext;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueDosage?: Dosage;

  /**
   * The value that should be used if there is no value stated in the
   * instance (e.g. 'if not otherwise specified, the abstract is false').
   */
  readonly defaultValueMeta?: Meta;

  /**
   * The Implicit meaning that is to be understood when this element is
   * missing (e.g. 'when this element is missing, the period is ongoing').
   */
  readonly meaningWhenMissing?: string;

  /**
   * If present, indicates that the order of the repeating element has
   * meaning and describes what that meaning is.  If absent, it means that
   * the order of the element has no meaning.
   */
  readonly orderMeaning?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedBase64Binary?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedBoolean?: boolean;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedCanonical?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedCode?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDate?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDateTime?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDecimal?: number;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedId?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedInstant?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedInteger?: number;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedMarkdown?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedOid?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedPositiveInt?: number;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedString?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedTime?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedUnsignedInt?: number;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedUri?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedUrl?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedUuid?: string;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedAddress?: Address;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedAge?: Age;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedAnnotation?: Annotation;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedAttachment?: Attachment;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedCodeableConcept?: CodeableConcept;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedCoding?: Coding;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedContactPoint?: ContactPoint;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedCount?: Count;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDistance?: Distance;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDuration?: Duration;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedHumanName?: HumanName;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedIdentifier?: Identifier;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedMoney?: Money;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedPeriod?: Period;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedQuantity?: Quantity;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedRange?: Range;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedRatio?: Ratio;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedReference?: Reference;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedSampledData?: SampledData;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedSignature?: Signature;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedTiming?: Timing;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedContactDetail?: ContactDetail;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedContributor?: Contributor;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDataRequirement?: DataRequirement;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedExpression?: Expression;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedParameterDefinition?: ParameterDefinition;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedRelatedArtifact?: RelatedArtifact;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedUsageContext?: UsageContext;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedDosage?: Dosage;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in
   * the instance. For purposes of comparison, non-significant whitespace
   * is ignored, and all values must be an exact match (case and accent
   * sensitive). Missing elements/attributes must also be missing.
   */
  readonly fixedMeta?: Meta;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternBase64Binary?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternBoolean?: boolean;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternCanonical?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternCode?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDate?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDateTime?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDecimal?: number;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternId?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternInstant?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternInteger?: number;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternMarkdown?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternOid?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternPositiveInt?: number;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternString?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternTime?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternUnsignedInt?: number;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternUri?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternUrl?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternUuid?: string;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternAddress?: Address;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternAge?: Age;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternAnnotation?: Annotation;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternAttachment?: Attachment;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternCodeableConcept?: CodeableConcept;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternCoding?: Coding;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternContactPoint?: ContactPoint;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternCount?: Count;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDistance?: Distance;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDuration?: Duration;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternHumanName?: HumanName;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternIdentifier?: Identifier;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternMoney?: Money;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternPeriod?: Period;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternQuantity?: Quantity;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternRange?: Range;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternRatio?: Ratio;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternReference?: Reference;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternSampledData?: SampledData;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternSignature?: Signature;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternTiming?: Timing;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternContactDetail?: ContactDetail;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternContributor?: Contributor;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDataRequirement?: DataRequirement;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternExpression?: Expression;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternParameterDefinition?: ParameterDefinition;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternRelatedArtifact?: RelatedArtifact;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternUsageContext?: UsageContext;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternDosage?: Dosage;

  /**
   * Specifies a value that the value in the instance SHALL follow - that
   * is, any value in the pattern must be found in the instance. Other
   * additional values may be found too. This is effectively constraint by
   * example.
   *
   * When pattern[x] is used to constrain a primitive, it means that the
   * value provided in the pattern[x] must match the instance value
   * exactly.
   *
   * When pattern[x] is used to constrain an array, it means that each
   * element provided in the pattern[x] array must (recursively) match at
   * least one element from the instance array.
   *
   * When pattern[x] is used to constrain a complex object, it means that
   * each property in the pattern must be present in the complex object,
   * and its value must recursively match -- i.e.,
   *
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
  readonly patternMeta?: Meta;

  /**
   * A sample value for this element demonstrating the type of information
   * that would typically be found in the element.
   */
  readonly example?: ElementDefinitionExample[];

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueDate?: string;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueDateTime?: string;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueInstant?: string;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueTime?: string;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueDecimal?: number;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueInteger?: number;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValuePositiveInt?: number;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueUnsignedInt?: number;

  /**
   * The minimum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly minValueQuantity?: Quantity;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueDate?: string;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueDateTime?: string;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueInstant?: string;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueTime?: string;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueDecimal?: number;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueInteger?: number;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValuePositiveInt?: number;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueUnsignedInt?: number;

  /**
   * The maximum allowed value for the element. The value is inclusive.
   * This is allowed for the types date, dateTime, instant, time, decimal,
   * integer, and Quantity.
   */
  readonly maxValueQuantity?: Quantity;

  /**
   * Indicates the maximum length in characters that is permitted to be
   * present in conformant instances and which is expected to be supported
   * by conformant consumers that support the element.
   */
  readonly maxLength?: number;

  /**
   * A reference to an invariant that may make additional statements about
   * the cardinality or value in the instance.
   */
  readonly condition?: string[];

  /**
   * Formal constraints such as co-occurrence and other constraints that
   * can be computationally evaluated within the context of the instance.
   */
  readonly constraint?: ElementDefinitionConstraint[];

  /**
   * If true, implementations that produce or consume resources SHALL
   * provide &quot;support&quot; for the element in some meaningful way.  If false,
   * the element may be ignored and not supported. If false, whether to
   * populate or use the data element in any way is at the discretion of
   * the implementation.
   */
  readonly mustSupport?: boolean;

  /**
   * If true, the value of this element affects the interpretation of the
   * element or resource that contains it, and the value of the element
   * cannot be ignored. Typically, this is used for status, negation and
   * qualification codes. The effect of this is that the element cannot be
   * ignored by systems: they SHALL either recognize the element and
   * process it, and/or a pre-determination has been made that it is not
   * relevant to their particular system.
   */
  readonly isModifier?: boolean;

  /**
   * Explains how that element affects the interpretation of the resource
   * or element that contains it.
   */
  readonly isModifierReason?: string;

  /**
   * Whether the element should be included if a client requests a search
   * with the parameter _summary=true.
   */
  readonly isSummary?: boolean;

  /**
   * Binds to a value set if this element is coded (code, Coding,
   * CodeableConcept, Quantity), or the data types (string, uri).
   */
  readonly binding?: ElementDefinitionBinding;

  /**
   * Identifies a concept from an external specification that roughly
   * corresponds to this element.
   */
  readonly mapping?: ElementDefinitionMapping[];
}

/**
 * Information about the base definition of the element, provided to make
 * it unnecessary for tools to trace the deviation of the element through
 * the derived and related profiles. When the element definition is not
 * the original definition of an element - i.g. either in a constraint on
 * another type, or for elements from a super type in a snap shot - then
 * the information in provided in the element definition may be different
 * to the base definition. On the original definition of the element, it
 * will be same.
 */
export interface ElementDefinitionBase {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * The Path that identifies the base element - this matches the
   * ElementDefinition.path for that element. Across FHIR, there is only
   * one base definition of any element - that is, an element definition on
   * a [StructureDefinition](structuredefinition.html#) without a
   * StructureDefinition.base.
   */
  readonly path?: string;

  /**
   * Minimum cardinality of the base element identified by the path.
   */
  readonly min?: number;

  /**
   * Maximum cardinality of the base element identified by the path.
   */
  readonly max?: string;
}

/**
 * Binds to a value set if this element is coded (code, Coding,
 * CodeableConcept, Quantity), or the data types (string, uri).
 */
export interface ElementDefinitionBinding {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * Indicates the degree of conformance expectations associated with this
   * binding - that is, the degree to which the provided value set must be
   * adhered to in the instances.
   */
  readonly strength?: string;

  /**
   * Describes the intended use of this particular set of codes.
   */
  readonly description?: string;

  /**
   * Refers to the value set that identifies the set of codes the binding
   * refers to.
   */
  readonly valueSet?: string;
}

/**
 * Formal constraints such as co-occurrence and other constraints that
 * can be computationally evaluated within the context of the instance.
 */
export interface ElementDefinitionConstraint {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * Allows identification of which elements have their cardinalities
   * impacted by the constraint.  Will not be referenced for constraints
   * that do not affect cardinality.
   */
  readonly key?: string;

  /**
   * Description of why this constraint is necessary or appropriate.
   */
  readonly requirements?: string;

  /**
   * Identifies the impact constraint violation has on the conformance of
   * the instance.
   */
  readonly severity?: string;

  /**
   * Text that can be used to describe the constraint in messages
   * identifying that the constraint has been violated.
   */
  readonly human?: string;

  /**
   * A [FHIRPath](fhirpath.html) expression of constraint that can be
   * executed to see if this constraint is met.
   */
  readonly expression?: string;

  /**
   * An XPath expression of constraint that can be executed to see if this
   * constraint is met.
   */
  readonly xpath?: string;

  /**
   * A reference to the original source of the constraint, for traceability
   * purposes.
   */
  readonly source?: string;
}

/**
 * A sample value for this element demonstrating the type of information
 * that would typically be found in the element.
 */
export interface ElementDefinitionExample {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * Describes the purpose of this example amoung the set of examples.
   */
  readonly label?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueBase64Binary?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueBoolean?: boolean;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueCanonical?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueCode?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDate?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDateTime?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDecimal?: number;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueId?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueInstant?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueInteger?: number;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueMarkdown?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueOid?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valuePositiveInt?: number;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueString?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueTime?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueUnsignedInt?: number;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueUri?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueUrl?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueUuid?: string;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueAddress?: Address;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueAge?: Age;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueAnnotation?: Annotation;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueAttachment?: Attachment;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueCodeableConcept?: CodeableConcept;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueCoding?: Coding;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueContactPoint?: ContactPoint;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueCount?: Count;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDistance?: Distance;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDuration?: Duration;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueHumanName?: HumanName;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueIdentifier?: Identifier;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueMoney?: Money;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valuePeriod?: Period;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueQuantity?: Quantity;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueRange?: Range;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueRatio?: Ratio;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueReference?: Reference;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueSampledData?: SampledData;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueSignature?: Signature;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueTiming?: Timing;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueContactDetail?: ContactDetail;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueContributor?: Contributor;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDataRequirement?: DataRequirement;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueExpression?: Expression;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueParameterDefinition?: ParameterDefinition;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueRelatedArtifact?: RelatedArtifact;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueTriggerDefinition?: TriggerDefinition;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueUsageContext?: UsageContext;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueDosage?: Dosage;

  /**
   * The actual value for the element, which must be one of the types
   * allowed for this element.
   */
  readonly valueMeta?: Meta;
}

/**
 * Identifies a concept from an external specification that roughly
 * corresponds to this element.
 */
export interface ElementDefinitionMapping {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * An internal reference to the definition of a mapping.
   */
  readonly identity?: string;

  /**
   * Identifies the computable language in which mapping.map is expressed.
   */
  readonly language?: string;

  /**
   * Expresses what part of the target specification corresponds to this
   * element.
   */
  readonly map?: string;

  /**
   * Comments that provide information about the mapping or its use.
   */
  readonly comment?: string;
}

/**
 * Indicates that the element is sliced into a set of alternative
 * definitions (i.e. in a structure definition, there are multiple
 * different constraints on a single element in the base resource).
 * Slicing can be used in any resource that has cardinality ..* on the
 * base resource, or any resource with a choice of types. The set of
 * slices is any elements that come after this in the element sequence
 * that have the same path, until a shorter path occurs (the shorter path
 * terminates the set).
 */
export interface ElementDefinitionSlicing {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * Designates which child elements are used to discriminate between the
   * slices when processing an instance. If one or more discriminators are
   * provided, the value of the child elements in the instance data SHALL
   * completely distinguish which slice the element in the resource matches
   * based on the allowed values for those elements in each of the slices.
   */
  readonly discriminator?: ElementDefinitionSlicingDiscriminator[];

  /**
   * A human-readable text description of how the slicing works. If there
   * is no discriminator, this is required to be present to provide
   * whatever information is possible about how the slices can be
   * differentiated.
   */
  readonly description?: string;

  /**
   * If the matching elements have to occur in the same order as defined in
   * the profile.
   */
  readonly ordered?: boolean;

  /**
   * Whether additional slices are allowed or not. When the slices are
   * ordered, profile authors can also say that additional slices are only
   * allowed at the end.
   */
  readonly rules?: string;
}

/**
 * Designates which child elements are used to discriminate between the
 * slices when processing an instance. If one or more discriminators are
 * provided, the value of the child elements in the instance data SHALL
 * completely distinguish which slice the element in the resource matches
 * based on the allowed values for those elements in each of the slices.
 */
export interface ElementDefinitionSlicingDiscriminator {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * How the element value is interpreted when discrimination is evaluated.
   */
  readonly type?: string;

  /**
   * A FHIRPath expression, using [the simple subset of
   * FHIRPath](fhirpath.html#simple), that is used to identify the element
   * on which discrimination is based.
   */
  readonly path?: string;
}

/**
 * The data type or resource that the value of this element is permitted
 * to be.
 */
export interface ElementDefinitionType {

  /**
   * Unique id for the element within a resource (for internal references).
   * This may be any string value that does not contain spaces.
   */
  readonly id?: string;

  /**
   * May be used to represent additional information that is not part of
   * the basic definition of the element. To make the use of extensions
   * safe and manageable, there is a strict set of governance  applied to
   * the definition and use of extensions. Though any implementer can
   * define an extension, there is a set of requirements that SHALL be met
   * as part of the definition of the extension.
   */
  readonly extension?: Extension[];

  /**
   * URL of Data type or Resource that is a(or the) type used for this
   * element. References are URLs that are relative to
   * http://hl7.org/fhir/StructureDefinition e.g. &quot;string&quot; is a reference
   * to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are
   * only allowed in logical models.
   */
  readonly code?: string;

  /**
   * Identifies a profile structure or implementation Guide that applies to
   * the datatype this element refers to. If any profiles are specified,
   * then the content must conform to at least one of them. The URL can be
   * a local reference - to a contained StructureDefinition, or a reference
   * to another StructureDefinition or Implementation Guide by a canonical
   * URL. When an implementation guide is specified, the type SHALL conform
   * to at least one profile defined in the implementation guide.
   */
  readonly profile?: string[];

  /**
   * Used when the type is &quot;Reference&quot; or &quot;canonical&quot;, and identifies a
   * profile structure or implementation Guide that applies to the target
   * of the reference this element refers to. If any profiles are
   * specified, then the content must conform to at least one of them. The
   * URL can be a local reference - to a contained StructureDefinition, or
   * a reference to another StructureDefinition or Implementation Guide by
   * a canonical URL. When an implementation guide is specified, the target
   * resource SHALL conform to at least one profile defined in the
   * implementation guide.
   */
  readonly targetProfile?: string[];

  /**
   * If the type is a reference to another resource, how the resource is or
   * can be aggregated - is it a contained resource, or a reference, and if
   * the context is a bundle, is it included in the bundle.
   */
  readonly aggregation?: string[];

  /**
   * Whether this reference needs to be version specific or version
   * independent, or whether either can be used.
   */
  readonly versioning?: string;
}
