---
sidebar_position: 2
toc_max_heading_level: 3
---

import ExampleCode from '!!raw-loader!@site/../examples/src/bots/finalize-report.test.ts';
import MedplumCodeBlock from '@site/src/components/MedplumCodeBlock';

# Unit Testing Bots

Unit testing your Bot code is crucial to ensuring accurate data and workflows. This guide will go over the most common unit testing patterns.

Medplum provides the [`MockClient`](https://github.com/medplum/medplum/blob/main/packages/mock/src/client.ts#L68) class to help unit test Bots on your local machine. You can also see a reference implementation of simple bots _with tests_ in our [Medplum Demo Bots](https://github.com/medplum/medplum-demo-bots) repo.

## Set up your test framework

The first step is to set up your test framework in your Bots package. Medplum Bots will should work with any typescript/javascript test runner, and the Medplum team has tested our bots with [jest](https://jestjs.io/) and [vitest](https://vitest.dev/). Follow the instructions for your favorite framework to set up you package.

Next you'll want to index the FHIR schema definitions. To keep the client small, the `MockClient` class only ships with a subset of the FHIR schema. Index the full schema as shown below, either in a [`beforeAll` function](https://vitest.dev/api/#beforeall) or [setup file](https://vitest.dev/config/#setupfiles), to make sure your [test queries](##query-the-results) work.

<MedplumCodeBlock language="ts" selectBlocks="index-schema">
  {ExampleCode}
</MedplumCodeBlock>

Our [Medplum Demo Bots](https://github.com/medplum/medplum-demo-bots) repo also contains recommended [eslintrc](https://github.com/medplum/medplum-demo-bots/blob/main/.eslintrc.json), [tsconfig](https://github.com/medplum/medplum-demo-bots/blob/main/tsconfig.json), and [vite.config](https://github.com/medplum/medplum-demo-bots/blob/main/vite.config.ts) settings for a faster developer feedback cycle.

## Write your test file

After setting up your framework, you're ready to write your first test file! The most common convention is to create a single test file per bot, named `<botname>.test.ts`.

You will need to import your bot's `handler` function, in addition to the other imports required by your test framework. You'll call this `handler` from each one of your tests.

```typescript
import { handler } from './my-bot';
```

## Write your unit test

Most bot unit tests follow a common pattern:

1. Create a Medplum `MockClient`
2. Create mock resources
3. Invoke the handler function
4. Query mock resources and assert test your test criteria

The [finalize-report tests](https://github.com/medplum/medplum-demo-bots/blob/main/src/examples/finalize-report.ts) are a great example of this pattern.

### Create a `MockClient`

The Medplum `MockClient` class extends the `MedplumClient` class, but stores resources in local memory rather than persisting them to the server. This presents a type-compatible interface to the Bot's handler function, which makes it ideal for unit tests.

<MedplumCodeBlock language="ts" selectBlocks="create-client">
  {ExampleCode}
</MedplumCodeBlock>

We recommend creating a `MockClient` at the beginning of each test, to avoid any cross-talk between tests.

:::warning Caution

The MockClient does not yet _perfectly_ replicate the functionality of the `MedplumClient` class, as this would require duplicating the entire server codebase. Some advanced functionality does not yet behave the same between `MockClient` and `MedplumClient`, including:

- `medplum.graphql`
- FHIR $ operations

The Medplum team is working on bringing these features to parity as soon as possible.

:::

### Create mock resource resources

Most tests require setting up some resources in the mock environment before running the Bot. You can use `createResource()` and `updateResource()` to add resources to your mock server, just as you would with a regular `MedplumClient` instance.

The [finalize-report bot](https://github.com/medplum/medplum-demo-bots/blob/main/src/examples/finalize-reports.test.ts) from [Medplum Demo Bots](https://github.com/medplum/medplum-demo-bots/) provides a good example. Each test sets up a [Patient](/docs/api/fhir/resources/patient), an [Observation](/docs/api/fhir/resources/observation), and a [DiagnosticReport](/docs/api/fhir/resources/diagnosticreport) before invoking the bot.

<details>
  <summary>Example: Create Resources</summary>
  <MedplumCodeBlock language="ts" selectBlocks="create-resources">
    {ExampleCode}
  </MedplumCodeBlock>
</details>

### Invoke your Bot

After setting up your mock resources, you can invoke your bot by calling your bot's handler function. See the ["Bot Basics" tutorial](/docs/bots/bot-basics#editing-a-bot) for more information about the arguments to `handler`

<MedplumCodeBlock language="ts" selectBlocks="invoke-bot">
  {ExampleCode}
</MedplumCodeBlock>

### Query the results

Most of the time, Bots will create or modify resources on the Medplum server. To test your bot, you can use your `MockClient` to query the state of resources on the server, just as you would with a `MedplumClient` in production.

To check the bot's response, simply check the return value of your `handler` function.

The after running the Bot, the [finalize-report bot's tests](https://github.com/medplum/medplum-demo-bots/blob/main/src/examples/finalize-reports.test.ts) read the updated `DiagnosticReport` and `Observation` resources to confirm their status.

<details>
  <summary>Example: Query the results</summary>
  <MedplumCodeBlock language="ts" selectBlocks="query-results">
    {ExampleCode}
  </MedplumCodeBlock>
</details>

:::note A note on idempotency
Many times, you'd like to make sure your Bot is [idempotent](https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning). This can be accomplished by calling your bot twice, and using your test framework's `spyOn` functions to ensure that no resources are created/updated in the second call.

<details>
  <summary>Example: Idempotency test</summary>
  <MedplumCodeBlock language="ts" selectBlocks="test-idempotent">
    {ExampleCode}
  </MedplumCodeBlock>
</details>

:::

### Creating Rich Test Data in Batches

Creating individual test resources can be time consuming and tedious, so the `MockClient` also offers the ability to use batch requests to set up sample data.

Batch requests use `Bundle` resources to make multiple API calls as part of a single HTTP request, and can be used to quickly create rich data for testing. See [here](https://github.com/medplum/medplum/blob/main/examples/medplum-demo-bots/src/deduplication/patient-data.json) for an example of a `Bundle` that can be used for a batch transaction.

The `MockClient` offers the `executeBatch` helper function to easily execute batch requests and works in the same way that the standard Medplum Client does. For more details on how to make batch requests see the [FHIR Batch Requests docs](docs/fhir-datastore/fhir-batch-requests).

<details><summary>Example: Creating a large set of patient data with a batch request</summary>

```ts
import patientData from './patient-data.json';

interface TestContext {
  medplum: MedplumClient;
}

// ...

beforeEach<TestContext>(async (context) => {
  context.medplum = new MockClient();
  await context.medplum.executeBatch(patientData as Bundle);
});

test<TestContext>('Created RiskAssessment', async ({ medplum }) => {
  // Read the patient
  const patients = await medplum.searchResources('Patient', { given: 'Alex' });

  await handler(medplum, { input: patients?.[0] as Patient, contentType: ContentType.FHIR_JSON, secrets: {} });

  // We expect two risk assessments to be created for the two candidate matches
  const riskAssessments = await medplum.searchResources('RiskAssessment');
  expect(riskAssessments.length).toBe(2);
  expect(riskAssessments.every((assessment) => resolveId(assessment.subject) === patients[0].id));
});
```

</details>

In this example we import the `patientData`, then create the `MockClient` and test data in the `beforeEach` function. The test data is created by calling `executeBatch` on our `patientData`, allowing us to create it in one HTTP request. The `beforeEach` function is an optimization that will run before each test, so you do not need to create the data as a part of every test.

Once you have created your data, you can write your tests, passing the context in as `{ medplum }` for your argument. This test is checking that a `RiskAssessment` was created when looking for potential duplicate patients.

### Using the Medplum CLI

If you have a dev project that already has rich data, you can use the Mepdlum CLI to easily convert this data into test data.

The Medplum CLI offers the optional `--as-transaction` flag when using the `medplum get` command. A `GET` request returns a 'Bundle' with `type=searchset`, but this flag will convert it to `type=transaction`.

A transaction `Bundle` can be used directly in a batch request, and can be passed as an argument to `executeBatch` on your `MockClient`. This allows you to easily create test resoures from already existing data.
