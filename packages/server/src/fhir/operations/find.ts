// SPDX-FileCopyrightText: Copyright Orangebot, Inc. and Medplum contributors
// SPDX-License-Identifier: Apache-2.0
import {
  allOk,
  badRequest,
  createReference,
  DEFAULT_MAX_SEARCH_COUNT,
  DEFAULT_SEARCH_COUNT,
  OperationOutcomeError,
  Operator,
} from '@medplum/core';
import type { FhirRequest, FhirResponse } from '@medplum/fhir-router';
import type { Bundle, OperationDefinition, Schedule, Slot } from '@medplum/fhirtypes';
import { getAuthenticatedContext } from '../../context';
import { applyExistingSlots, findSlotTimes, resolveAvailability } from './utils/find';
import { buildOutputParameters, parseInputParameters } from './utils/parameters';
import { parseSchedulingParametersExtensions } from './utils/scheduling-parameters';

const findOperation = {
  resourceType: 'OperationDefinition',
  name: 'find',
  status: 'active',
  kind: 'operation',
  code: 'find',
  resource: ['Schedule'],
  system: false,
  type: true,
  instance: true,
  parameter: [
    { use: 'in', name: 'start', type: 'dateTime', min: 1, max: '1' },
    { use: 'in', name: 'end', type: 'dateTime', min: 1, max: '1' },
    { use: 'out', name: 'return', type: 'Bundle', min: 0, max: '1' },
  ],
} as const satisfies OperationDefinition;

type FindParameters = {
  start: string;
  end: string;
};

const TimezoneExtensionURI = 'http://hl7.org/fhir/StructureDefinition/timezone';
function getTimeZone(schedule: Schedule): string | undefined {
  return (schedule.extension ?? []).find((extension) => extension.url === TimezoneExtensionURI)?.valueCode;
}

/**
 * Handles HTTP requests for the Schedule $find operation.
 *
 * Endpoints:
 *   [fhir base]/Schedule/[id]/$find
 *
 * @param req - The FHIR request.
 * @returns The FHIR response.
 */
export async function scheduleFindHandler(req: FhirRequest): Promise<FhirResponse> {
  const ctx = getAuthenticatedContext();
  const params = parseInputParameters<FindParameters>(findOperation, req);
  const { start, end } = params;

  // Future performance option: parameterize availability search with this
  // count so we can quit early once we have identified enough slots.
  const pageSize = DEFAULT_SEARCH_COUNT;

  const range = { start: new Date(params.start), end: new Date(params.end) };

  if (range.start >= range.end) {
    throw new OperationOutcomeError(badRequest('Invalid search time range'));
  }

  const diffMilliseconds = range.end.valueOf() - range.start.valueOf();
  const diffDays = diffMilliseconds / (24 * 60 * 60 * 1000);
  if (diffDays > 31) {
    throw new OperationOutcomeError(badRequest('Search range cannot exceed 31 days'));
  }

  const [schedule, slots] = await Promise.all([
    ctx.repo.readResource<Schedule>('Schedule', req.params.id),
    ctx.repo.searchResources<Slot>({
      resourceType: 'Slot',

      count: DEFAULT_MAX_SEARCH_COUNT,

      filters: [
        {
          code: 'schedule',
          operator: Operator.EQUALS,
          value: `Schedule/${req.params.id}`,
        },

        {
          code: '_filter',
          operator: Operator.EQUALS,
          // Slot starts sometime in range, OR
          // Slot ends sometime in range, OR
          // Slot time fully contains range
          value: `((start ge "${start}" and start le "${end}") or (end ge "${start}" and end le "${end}") or (start lt "${start}" and end gt "${end}"))`,
        },

        {
          code: 'status',
          operator: Operator.EQUALS,
          value: 'busy,free,busy-unavailable',
        },
      ],
    }),
  ]);

  // If we filled a full search page of slots, then there may be slots we
  // didn't fetch that would impact availability. Fail loudly here.
  if (slots.length === DEFAULT_MAX_SEARCH_COUNT) {
    throw new OperationOutcomeError(badRequest('Too many slots found in range; try searching with smaller bounds'));
  }

  const timeZone = getTimeZone(schedule);
  if (!timeZone) {
    throw new OperationOutcomeError(badRequest('No timezone specified'));
  }

  const allSchedulingParameters = parseSchedulingParametersExtensions(schedule);
  const schedulingParameters = allSchedulingParameters.find((p) => p.serviceType.length === 0);

  if (!schedulingParameters) {
    throw new OperationOutcomeError(badRequest('No matching scheduling parameters found'));
  }

  const scheduleAvailability = resolveAvailability(schedulingParameters, range, timeZone);
  const availability = applyExistingSlots(scheduleAvailability, slots, range);

  const resultSlots: Slot[] = findSlotTimes(schedulingParameters, availability).map(({ start, end }) => ({
    resourceType: 'Slot',
    start: start.toISOString(),
    end: end.toISOString(),
    schedule: createReference(schedule),
    status: 'free',
  }));

  const bundle: Bundle<Slot> = {
    resourceType: 'Bundle',
    type: 'searchset',
    entry: resultSlots.slice(0, pageSize).map((slot) => ({ resource: slot })),
  };

  return [allOk, buildOutputParameters(findOperation, bundle)];
}
